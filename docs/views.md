# Views


## Overriding Views

When using the view generator _shorts_ will create a class and apply it to the
owning module. The new class exists as if the written by hand:

In `products.views`:

```py
from django.shortcuts import render # default import

from short import views as shorts
shorts.crud_classes()
```

This will generate a _create/detail/update/delete_ set of classes for each model
within `product.models`. Eventually you'll outgrow the default _shorts view_ and
apply your own:



In `products.views`:

```py
from django.shortcuts import render # default import

from short import views as shorts
from . import models # import the relative products.models module.


shorts.crud_classes()

class MyModelDetailView(shorts.DetailView):
    model = models.MyModel

    def get_context_data(self, **kwargs):
        kwargs['foo'] = 'FOO'
        return kwargs

```

This will override any class generated by `shorts.crud_classes()`.  The call position
is not important as _shorts_ will detect the manual override:

In `products.views` (alternative for the above):

```py
from django.shortcuts import render # default import

from short import views as shorts
from . import models # import the relative products.models module.


class MyModelDetailView(shorts.DetailView):
    """Override short.short crud classes generate and replace the detail view
    for MyModel with this custom View.

    The template `templates/products/mymodel_detail.html` must exist.
    """
    model = models.MyModel


shorts.crud_classes() # Will detect MyModelDetailView and reuse it.
```

